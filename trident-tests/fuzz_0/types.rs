//! # Trident Generated Types
//!
//! This file is automatically generated by Trident.
//! **DO NOT EDIT THIS FILE MANUALLY**

#![allow(dead_code)]
#![allow(unused_imports)]

use borsh::BorshDeserialize;
use borsh::BorshSerialize;
use trident_fuzz::fuzzing::*;

// ============================================================================
// PROGRAM MODULES
// ============================================================================

// ----------------------------------------------------------------------------
// Program: solana_stablecoin_standard
// ----------------------------------------------------------------------------
pub mod solana_stablecoin_standard {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for solana_stablecoin_standard
    pub fn program_id() -> Pubkey {
        pubkey!("47TNsKC1iJvLTKYRMbfYjrod4a56YE1f4qv73hZkdWUZ")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: AddToBlacklist
    // ....................................................................

    /// Main instruction struct for AddToBlacklist
    pub struct AddToBlacklistInstruction {
        pub accounts: AddToBlacklistInstructionAccountMetas,
        pub data: AddToBlacklistInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for AddToBlacklist instruction
    #[derive(Debug, Clone, Default)]
    pub struct AddToBlacklistInstructionAccountMetas {
        pub blacklister: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub blacklist_entry: AccountMeta,

        pub address: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for AddToBlacklist instruction
    #[derive(Debug, Clone)]
    pub struct AddToBlacklistInstructionAccounts {
        pub blacklister: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub blacklist_entry: Pubkey,

        pub address: Pubkey,
    }

    impl AddToBlacklistInstructionAccounts {
        pub fn new(
            blacklister: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            blacklist_entry: Pubkey,

            address: Pubkey,
        ) -> Self {
            Self {
                blacklister,

                stablecoin,

                role,

                blacklist_entry,

                address,
            }
        }
    }

    /// Instruction data for AddToBlacklist
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct AddToBlacklistInstructionData {
        pub reason: String,
    }

    impl AddToBlacklistInstructionData {
        pub fn new(reason: String) -> Self {
            Self { reason }
        }
    }

    /// Implementation for AddToBlacklistInstruction
    impl AddToBlacklistInstruction {
        fn discriminator() -> [u8; 8] {
            [90u8, 115u8, 98u8, 231u8, 173u8, 119u8, 117u8, 176u8]
        }

        pub fn data(data: AddToBlacklistInstructionData) -> Self {
            Self {
                accounts: AddToBlacklistInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: AddToBlacklistInstructionAccounts) -> Self {
            self.accounts.blacklister = AccountMeta::new(accounts.blacklister, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.blacklist_entry = AccountMeta::new(accounts.blacklist_entry, false);

            self.accounts.address = AccountMeta::new_readonly(accounts.address, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.blacklister.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.blacklist_entry.clone());

            metas.push(self.accounts.address.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: BurnTokens
    // ....................................................................

    /// Main instruction struct for BurnTokens
    pub struct BurnTokensInstruction {
        pub accounts: BurnTokensInstructionAccountMetas,
        pub data: BurnTokensInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for BurnTokens instruction
    #[derive(Debug, Clone, Default)]
    pub struct BurnTokensInstructionAccountMetas {
        pub burner: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub mint: AccountMeta,

        pub burner_token_account: AccountMeta,

        pub token_program: AccountMeta,
    }

    /// Account pubkeys for BurnTokens instruction
    #[derive(Debug, Clone)]
    pub struct BurnTokensInstructionAccounts {
        pub burner: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub mint: Pubkey,

        pub burner_token_account: Pubkey,
    }

    impl BurnTokensInstructionAccounts {
        pub fn new(
            burner: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            mint: Pubkey,

            burner_token_account: Pubkey,
        ) -> Self {
            Self {
                burner,

                stablecoin,

                role,

                mint,

                burner_token_account,
            }
        }
    }

    /// Instruction data for BurnTokens
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct BurnTokensInstructionData {
        pub amount: u64,
    }

    impl BurnTokensInstructionData {
        pub fn new(amount: u64) -> Self {
            Self { amount }
        }
    }

    /// Implementation for BurnTokensInstruction
    impl BurnTokensInstruction {
        fn discriminator() -> [u8; 8] {
            [76u8, 15u8, 51u8, 254u8, 229u8, 215u8, 121u8, 66u8]
        }

        pub fn data(data: BurnTokensInstructionData) -> Self {
            Self {
                accounts: BurnTokensInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: BurnTokensInstructionAccounts) -> Self {
            self.accounts.burner = AccountMeta::new_readonly(accounts.burner, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.mint = AccountMeta::new(accounts.mint, false);

            self.accounts.burner_token_account =
                AccountMeta::new(accounts.burner_token_account, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.burner.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.burner_token_account.clone());

            metas.push(self.accounts.token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: FreezeAccount
    // ....................................................................

    /// Main instruction struct for FreezeAccount
    pub struct FreezeAccountInstruction {
        pub accounts: FreezeAccountInstructionAccountMetas,
        pub data: FreezeAccountInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for FreezeAccount instruction
    #[derive(Debug, Clone, Default)]
    pub struct FreezeAccountInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub mint: AccountMeta,

        pub target_token_account: AccountMeta,

        pub token_program: AccountMeta,
    }

    /// Account pubkeys for FreezeAccount instruction
    #[derive(Debug, Clone)]
    pub struct FreezeAccountInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub mint: Pubkey,

        pub target_token_account: Pubkey,
    }

    impl FreezeAccountInstructionAccounts {
        pub fn new(
            authority: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            mint: Pubkey,

            target_token_account: Pubkey,
        ) -> Self {
            Self {
                authority,

                stablecoin,

                role,

                mint,

                target_token_account,
            }
        }
    }

    /// Instruction data for FreezeAccount
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct FreezeAccountInstructionData {}

    impl FreezeAccountInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for FreezeAccountInstruction
    impl FreezeAccountInstruction {
        fn discriminator() -> [u8; 8] {
            [253u8, 75u8, 82u8, 133u8, 167u8, 238u8, 43u8, 130u8]
        }

        pub fn data(data: FreezeAccountInstructionData) -> Self {
            Self {
                accounts: FreezeAccountInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: FreezeAccountInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.mint = AccountMeta::new_readonly(accounts.mint, false);

            self.accounts.target_token_account =
                AccountMeta::new(accounts.target_token_account, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.target_token_account.clone());

            metas.push(self.accounts.token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: InitializeStablecoin
    // ....................................................................

    /// Main instruction struct for InitializeStablecoin
    pub struct InitializeStablecoinInstruction {
        pub accounts: InitializeStablecoinInstructionAccountMetas,
        pub data: InitializeStablecoinInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for InitializeStablecoin instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeStablecoinInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub mint: AccountMeta,

        pub authority_role: AccountMeta,

        pub transfer_hook_program: AccountMeta,

        pub token_program: AccountMeta,

        pub system_program: AccountMeta,

        pub rent: AccountMeta,
    }

    /// Account pubkeys for InitializeStablecoin instruction
    #[derive(Debug, Clone)]
    pub struct InitializeStablecoinInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub mint: Pubkey,

        pub authority_role: Pubkey,

        pub transfer_hook_program: Pubkey,
    }

    impl InitializeStablecoinInstructionAccounts {
        pub fn new(
            authority: Pubkey,

            stablecoin: Pubkey,

            mint: Pubkey,

            authority_role: Pubkey,

            transfer_hook_program: Pubkey,
        ) -> Self {
            Self {
                authority,

                stablecoin,

                mint,

                authority_role,

                transfer_hook_program,
            }
        }
    }

    /// Instruction data for InitializeStablecoin
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeStablecoinInstructionData {
        pub params: InitializeParams,
    }

    impl InitializeStablecoinInstructionData {
        pub fn new(params: InitializeParams) -> Self {
            Self { params }
        }
    }

    /// Implementation for InitializeStablecoinInstruction
    impl InitializeStablecoinInstruction {
        fn discriminator() -> [u8; 8] {
            [222u8, 57u8, 115u8, 168u8, 4u8, 94u8, 71u8, 36u8]
        }

        pub fn data(data: InitializeStablecoinInstructionData) -> Self {
            Self {
                accounts: InitializeStablecoinInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: InitializeStablecoinInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.mint = AccountMeta::new(accounts.mint, true);

            self.accounts.authority_role = AccountMeta::new(accounts.authority_role, false);

            self.accounts.transfer_hook_program =
                AccountMeta::new_readonly(accounts.transfer_hook_program, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self.accounts.rent = AccountMeta::new_readonly(
                pubkey!("SysvarRent111111111111111111111111111111111"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.authority_role.clone());

            metas.push(self.accounts.transfer_hook_program.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.system_program.clone());

            metas.push(self.accounts.rent.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: MintTokens
    // ....................................................................

    /// Main instruction struct for MintTokens
    pub struct MintTokensInstruction {
        pub accounts: MintTokensInstructionAccountMetas,
        pub data: MintTokensInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for MintTokens instruction
    #[derive(Debug, Clone, Default)]
    pub struct MintTokensInstructionAccountMetas {
        pub minter: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub minter_info: AccountMeta,

        pub mint: AccountMeta,

        pub recipient_token_account: AccountMeta,

        pub token_program: AccountMeta,

        pub supply_cap: AccountMeta,
    }

    /// Account pubkeys for MintTokens instruction
    #[derive(Debug, Clone)]
    pub struct MintTokensInstructionAccounts {
        pub minter: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub minter_info: Pubkey,

        pub mint: Pubkey,

        pub recipient_token_account: Pubkey,

        pub supply_cap: Pubkey,
    }

    impl MintTokensInstructionAccounts {
        pub fn new(
            minter: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            minter_info: Pubkey,

            mint: Pubkey,

            recipient_token_account: Pubkey,

            supply_cap: Pubkey,
        ) -> Self {
            Self {
                minter,

                stablecoin,

                role,

                minter_info,

                mint,

                recipient_token_account,

                supply_cap,
            }
        }
    }

    /// Instruction data for MintTokens
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct MintTokensInstructionData {
        pub amount: u64,
    }

    impl MintTokensInstructionData {
        pub fn new(amount: u64) -> Self {
            Self { amount }
        }
    }

    /// Implementation for MintTokensInstruction
    impl MintTokensInstruction {
        fn discriminator() -> [u8; 8] {
            [59u8, 132u8, 24u8, 246u8, 122u8, 39u8, 8u8, 243u8]
        }

        pub fn data(data: MintTokensInstructionData) -> Self {
            Self {
                accounts: MintTokensInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: MintTokensInstructionAccounts) -> Self {
            self.accounts.minter = AccountMeta::new_readonly(accounts.minter, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.minter_info = AccountMeta::new(accounts.minter_info, false);

            self.accounts.mint = AccountMeta::new(accounts.mint, false);

            self.accounts.recipient_token_account =
                AccountMeta::new(accounts.recipient_token_account, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self.accounts.supply_cap = AccountMeta::new_readonly(accounts.supply_cap, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.minter.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.minter_info.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.recipient_token_account.clone());

            metas.push(self.accounts.token_program.clone());

            metas.push(self.accounts.supply_cap.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Pause
    // ....................................................................

    /// Main instruction struct for Pause
    pub struct PauseInstruction {
        pub accounts: PauseInstructionAccountMetas,
        pub data: PauseInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Pause instruction
    #[derive(Debug, Clone, Default)]
    pub struct PauseInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,
    }

    /// Account pubkeys for Pause instruction
    #[derive(Debug, Clone)]
    pub struct PauseInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,
    }

    impl PauseInstructionAccounts {
        pub fn new(authority: Pubkey, stablecoin: Pubkey, role: Pubkey) -> Self {
            Self {
                authority,

                stablecoin,

                role,
            }
        }
    }

    /// Instruction data for Pause
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct PauseInstructionData {}

    impl PauseInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for PauseInstruction
    impl PauseInstruction {
        fn discriminator() -> [u8; 8] {
            [211u8, 22u8, 221u8, 251u8, 74u8, 121u8, 193u8, 47u8]
        }

        pub fn data(data: PauseInstructionData) -> Self {
            Self {
                accounts: PauseInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: PauseInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: RemoveFromBlacklist
    // ....................................................................

    /// Main instruction struct for RemoveFromBlacklist
    pub struct RemoveFromBlacklistInstruction {
        pub accounts: RemoveFromBlacklistInstructionAccountMetas,
        pub data: RemoveFromBlacklistInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for RemoveFromBlacklist instruction
    #[derive(Debug, Clone, Default)]
    pub struct RemoveFromBlacklistInstructionAccountMetas {
        pub blacklister: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub blacklist_entry: AccountMeta,

        pub address: AccountMeta,
    }

    /// Account pubkeys for RemoveFromBlacklist instruction
    #[derive(Debug, Clone)]
    pub struct RemoveFromBlacklistInstructionAccounts {
        pub blacklister: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub blacklist_entry: Pubkey,

        pub address: Pubkey,
    }

    impl RemoveFromBlacklistInstructionAccounts {
        pub fn new(
            blacklister: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            blacklist_entry: Pubkey,

            address: Pubkey,
        ) -> Self {
            Self {
                blacklister,

                stablecoin,

                role,

                blacklist_entry,

                address,
            }
        }
    }

    /// Instruction data for RemoveFromBlacklist
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct RemoveFromBlacklistInstructionData {}

    impl RemoveFromBlacklistInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for RemoveFromBlacklistInstruction
    impl RemoveFromBlacklistInstruction {
        fn discriminator() -> [u8; 8] {
            [47u8, 105u8, 20u8, 10u8, 165u8, 168u8, 203u8, 219u8]
        }

        pub fn data(data: RemoveFromBlacklistInstructionData) -> Self {
            Self {
                accounts: RemoveFromBlacklistInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: RemoveFromBlacklistInstructionAccounts) -> Self {
            self.accounts.blacklister = AccountMeta::new(accounts.blacklister, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.blacklist_entry = AccountMeta::new(accounts.blacklist_entry, false);

            self.accounts.address = AccountMeta::new_readonly(accounts.address, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.blacklister.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.blacklist_entry.clone());

            metas.push(self.accounts.address.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Seize
    // ....................................................................

    /// Main instruction struct for Seize
    pub struct SeizeInstruction {
        pub accounts: SeizeInstructionAccountMetas,
        pub data: SeizeInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Seize instruction
    #[derive(Debug, Clone, Default)]
    pub struct SeizeInstructionAccountMetas {
        pub seizer: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub mint: AccountMeta,

        pub source_token_account: AccountMeta,

        pub destination_token_account: AccountMeta,

        pub transfer_hook_program: AccountMeta,

        pub extra_account_metas: AccountMeta,

        pub sss_token_program: AccountMeta,

        pub source_blacklist: AccountMeta,

        pub dest_blacklist: AccountMeta,

        pub token_program: AccountMeta,
    }

    /// Account pubkeys for Seize instruction
    #[derive(Debug, Clone)]
    pub struct SeizeInstructionAccounts {
        pub seizer: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub mint: Pubkey,

        pub source_token_account: Pubkey,

        pub destination_token_account: Pubkey,

        pub transfer_hook_program: Pubkey,

        pub extra_account_metas: Pubkey,

        pub source_blacklist: Pubkey,

        pub dest_blacklist: Pubkey,
    }

    impl SeizeInstructionAccounts {
        pub fn new(
            seizer: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            mint: Pubkey,

            source_token_account: Pubkey,

            destination_token_account: Pubkey,

            transfer_hook_program: Pubkey,

            extra_account_metas: Pubkey,

            source_blacklist: Pubkey,

            dest_blacklist: Pubkey,
        ) -> Self {
            Self {
                seizer,

                stablecoin,

                role,

                mint,

                source_token_account,

                destination_token_account,

                transfer_hook_program,

                extra_account_metas,

                source_blacklist,

                dest_blacklist,
            }
        }
    }

    /// Instruction data for Seize
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct SeizeInstructionData {}

    impl SeizeInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for SeizeInstruction
    impl SeizeInstruction {
        fn discriminator() -> [u8; 8] {
            [129u8, 159u8, 143u8, 31u8, 161u8, 224u8, 241u8, 84u8]
        }

        pub fn data(data: SeizeInstructionData) -> Self {
            Self {
                accounts: SeizeInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: SeizeInstructionAccounts) -> Self {
            self.accounts.seizer = AccountMeta::new_readonly(accounts.seizer, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.mint = AccountMeta::new_readonly(accounts.mint, false);

            self.accounts.source_token_account =
                AccountMeta::new(accounts.source_token_account, false);

            self.accounts.destination_token_account =
                AccountMeta::new(accounts.destination_token_account, false);

            self.accounts.transfer_hook_program =
                AccountMeta::new_readonly(accounts.transfer_hook_program, false);

            self.accounts.extra_account_metas =
                AccountMeta::new_readonly(accounts.extra_account_metas, false);

            self.accounts.sss_token_program = AccountMeta::new_readonly(
                pubkey!("47TNsKC1iJvLTKYRMbfYjrod4a56YE1f4qv73hZkdWUZ"),
                false,
            );

            self.accounts.source_blacklist =
                AccountMeta::new_readonly(accounts.source_blacklist, false);

            self.accounts.dest_blacklist =
                AccountMeta::new_readonly(accounts.dest_blacklist, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.seizer.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.source_token_account.clone());

            metas.push(self.accounts.destination_token_account.clone());

            metas.push(self.accounts.transfer_hook_program.clone());

            metas.push(self.accounts.extra_account_metas.clone());

            metas.push(self.accounts.sss_token_program.clone());

            metas.push(self.accounts.source_blacklist.clone());

            metas.push(self.accounts.dest_blacklist.clone());

            metas.push(self.accounts.token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: ThawAccount
    // ....................................................................

    /// Main instruction struct for ThawAccount
    pub struct ThawAccountInstruction {
        pub accounts: ThawAccountInstructionAccountMetas,
        pub data: ThawAccountInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for ThawAccount instruction
    #[derive(Debug, Clone, Default)]
    pub struct ThawAccountInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub mint: AccountMeta,

        pub target_token_account: AccountMeta,

        pub token_program: AccountMeta,
    }

    /// Account pubkeys for ThawAccount instruction
    #[derive(Debug, Clone)]
    pub struct ThawAccountInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub mint: Pubkey,

        pub target_token_account: Pubkey,
    }

    impl ThawAccountInstructionAccounts {
        pub fn new(
            authority: Pubkey,

            stablecoin: Pubkey,

            role: Pubkey,

            mint: Pubkey,

            target_token_account: Pubkey,
        ) -> Self {
            Self {
                authority,

                stablecoin,

                role,

                mint,

                target_token_account,
            }
        }
    }

    /// Instruction data for ThawAccount
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct ThawAccountInstructionData {}

    impl ThawAccountInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for ThawAccountInstruction
    impl ThawAccountInstruction {
        fn discriminator() -> [u8; 8] {
            [115u8, 152u8, 79u8, 213u8, 213u8, 169u8, 184u8, 35u8]
        }

        pub fn data(data: ThawAccountInstructionData) -> Self {
            Self {
                accounts: ThawAccountInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: ThawAccountInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self.accounts.mint = AccountMeta::new_readonly(accounts.mint, false);

            self.accounts.target_token_account =
                AccountMeta::new(accounts.target_token_account, false);

            self.accounts.token_program = AccountMeta::new_readonly(
                pubkey!("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"),
                false,
            );

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.target_token_account.clone());

            metas.push(self.accounts.token_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: TransferAuthority
    // ....................................................................

    /// Main instruction struct for TransferAuthority
    pub struct TransferAuthorityInstruction {
        pub accounts: TransferAuthorityInstructionAccountMetas,
        pub data: TransferAuthorityInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for TransferAuthority instruction
    #[derive(Debug, Clone, Default)]
    pub struct TransferAuthorityInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub new_authority: AccountMeta,
    }

    /// Account pubkeys for TransferAuthority instruction
    #[derive(Debug, Clone)]
    pub struct TransferAuthorityInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub new_authority: Pubkey,
    }

    impl TransferAuthorityInstructionAccounts {
        pub fn new(authority: Pubkey, stablecoin: Pubkey, new_authority: Pubkey) -> Self {
            Self {
                authority,

                stablecoin,

                new_authority,
            }
        }
    }

    /// Instruction data for TransferAuthority
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct TransferAuthorityInstructionData {}

    impl TransferAuthorityInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for TransferAuthorityInstruction
    impl TransferAuthorityInstruction {
        fn discriminator() -> [u8; 8] {
            [48u8, 169u8, 76u8, 72u8, 229u8, 180u8, 55u8, 161u8]
        }

        pub fn data(data: TransferAuthorityInstructionData) -> Self {
            Self {
                accounts: TransferAuthorityInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: TransferAuthorityInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.new_authority = AccountMeta::new_readonly(accounts.new_authority, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.new_authority.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: Unpause
    // ....................................................................

    /// Main instruction struct for Unpause
    pub struct UnpauseInstruction {
        pub accounts: UnpauseInstructionAccountMetas,
        pub data: UnpauseInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for Unpause instruction
    #[derive(Debug, Clone, Default)]
    pub struct UnpauseInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,
    }

    /// Account pubkeys for Unpause instruction
    #[derive(Debug, Clone)]
    pub struct UnpauseInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,
    }

    impl UnpauseInstructionAccounts {
        pub fn new(authority: Pubkey, stablecoin: Pubkey, role: Pubkey) -> Self {
            Self {
                authority,

                stablecoin,

                role,
            }
        }
    }

    /// Instruction data for Unpause
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct UnpauseInstructionData {}

    impl UnpauseInstructionData {
        pub fn new() -> Self {
            Self {}
        }
    }

    /// Implementation for UnpauseInstruction
    impl UnpauseInstruction {
        fn discriminator() -> [u8; 8] {
            [169u8, 144u8, 4u8, 38u8, 10u8, 141u8, 188u8, 255u8]
        }

        pub fn data(data: UnpauseInstructionData) -> Self {
            Self {
                accounts: UnpauseInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: UnpauseInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new_readonly(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new_readonly(accounts.role, false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: UpdateMinter
    // ....................................................................

    /// Main instruction struct for UpdateMinter
    pub struct UpdateMinterInstruction {
        pub accounts: UpdateMinterInstructionAccountMetas,
        pub data: UpdateMinterInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for UpdateMinter instruction
    #[derive(Debug, Clone, Default)]
    pub struct UpdateMinterInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub minter_info: AccountMeta,

        pub minter: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for UpdateMinter instruction
    #[derive(Debug, Clone)]
    pub struct UpdateMinterInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub minter_info: Pubkey,

        pub minter: Pubkey,
    }

    impl UpdateMinterInstructionAccounts {
        pub fn new(
            authority: Pubkey,

            stablecoin: Pubkey,

            minter_info: Pubkey,

            minter: Pubkey,
        ) -> Self {
            Self {
                authority,

                stablecoin,

                minter_info,

                minter,
            }
        }
    }

    /// Instruction data for UpdateMinter
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct UpdateMinterInstructionData {
        pub quota: u64,
    }

    impl UpdateMinterInstructionData {
        pub fn new(quota: u64) -> Self {
            Self { quota }
        }
    }

    /// Implementation for UpdateMinterInstruction
    impl UpdateMinterInstruction {
        fn discriminator() -> [u8; 8] {
            [164u8, 129u8, 164u8, 88u8, 75u8, 29u8, 91u8, 38u8]
        }

        pub fn data(data: UpdateMinterInstructionData) -> Self {
            Self {
                accounts: UpdateMinterInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: UpdateMinterInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.minter_info = AccountMeta::new(accounts.minter_info, false);

            self.accounts.minter = AccountMeta::new_readonly(accounts.minter, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.minter_info.clone());

            metas.push(self.accounts.minter.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ....................................................................
    // Instruction: UpdateRoles
    // ....................................................................

    /// Main instruction struct for UpdateRoles
    pub struct UpdateRolesInstruction {
        pub accounts: UpdateRolesInstructionAccountMetas,
        pub data: UpdateRolesInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for UpdateRoles instruction
    #[derive(Debug, Clone, Default)]
    pub struct UpdateRolesInstructionAccountMetas {
        pub authority: AccountMeta,

        pub stablecoin: AccountMeta,

        pub role: AccountMeta,

        pub holder: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for UpdateRoles instruction
    #[derive(Debug, Clone)]
    pub struct UpdateRolesInstructionAccounts {
        pub authority: Pubkey,

        pub stablecoin: Pubkey,

        pub role: Pubkey,

        pub holder: Pubkey,
    }

    impl UpdateRolesInstructionAccounts {
        pub fn new(authority: Pubkey, stablecoin: Pubkey, role: Pubkey, holder: Pubkey) -> Self {
            Self {
                authority,

                stablecoin,

                role,

                holder,
            }
        }
    }

    /// Instruction data for UpdateRoles
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct UpdateRolesInstructionData {
        pub roles: RoleFlags,
    }

    impl UpdateRolesInstructionData {
        pub fn new(roles: RoleFlags) -> Self {
            Self { roles }
        }
    }

    /// Implementation for UpdateRolesInstruction
    impl UpdateRolesInstruction {
        fn discriminator() -> [u8; 8] {
            [220u8, 152u8, 205u8, 233u8, 177u8, 123u8, 219u8, 125u8]
        }

        pub fn data(data: UpdateRolesInstructionData) -> Self {
            Self {
                accounts: UpdateRolesInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(mut self, accounts: UpdateRolesInstructionAccounts) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.stablecoin = AccountMeta::new_readonly(accounts.stablecoin, false);

            self.accounts.role = AccountMeta::new(accounts.role, false);

            self.accounts.holder = AccountMeta::new_readonly(accounts.holder, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.stablecoin.clone());

            metas.push(self.accounts.role.clone());

            metas.push(self.accounts.holder.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ----------------------------------------------------------------------------
// Program: sss_transfer_hook
// ----------------------------------------------------------------------------
pub mod sss_transfer_hook {
    use super::*;

    // ------------------------------------------------------------------------
    // Program ID
    // ------------------------------------------------------------------------

    /// Returns the program ID for sss_transfer_hook
    pub fn program_id() -> Pubkey {
        pubkey!("8DMsf39fGWfcrWVjfyEq8fqZf5YcTvVPGgdJr8s2S8Nc")
    }

    // ------------------------------------------------------------------------
    // Instructions
    // ------------------------------------------------------------------------

    // ....................................................................
    // Instruction: InitializeExtraAccountMetaList
    // ....................................................................

    /// Main instruction struct for InitializeExtraAccountMetaList
    pub struct InitializeExtraAccountMetaListInstruction {
        pub accounts: InitializeExtraAccountMetaListInstructionAccountMetas,
        pub data: InitializeExtraAccountMetaListInstructionData,
        pub remaining_accounts: Vec<AccountMeta>,
    }

    /// Account metadata for InitializeExtraAccountMetaList instruction
    #[derive(Debug, Clone, Default)]
    pub struct InitializeExtraAccountMetaListInstructionAccountMetas {
        pub authority: AccountMeta,

        pub extra_account_meta_list: AccountMeta,

        pub mint: AccountMeta,

        pub system_program: AccountMeta,
    }

    /// Account pubkeys for InitializeExtraAccountMetaList instruction
    #[derive(Debug, Clone)]
    pub struct InitializeExtraAccountMetaListInstructionAccounts {
        pub authority: Pubkey,

        pub extra_account_meta_list: Pubkey,

        pub mint: Pubkey,
    }

    impl InitializeExtraAccountMetaListInstructionAccounts {
        pub fn new(authority: Pubkey, extra_account_meta_list: Pubkey, mint: Pubkey) -> Self {
            Self {
                authority,

                extra_account_meta_list,

                mint,
            }
        }
    }

    /// Instruction data for InitializeExtraAccountMetaList
    #[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
    pub struct InitializeExtraAccountMetaListInstructionData {
        pub sss_token_program_id: Pubkey,
    }

    impl InitializeExtraAccountMetaListInstructionData {
        pub fn new(sss_token_program_id: Pubkey) -> Self {
            Self {
                sss_token_program_id,
            }
        }
    }

    /// Implementation for InitializeExtraAccountMetaListInstruction
    impl InitializeExtraAccountMetaListInstruction {
        fn discriminator() -> [u8; 8] {
            [92u8, 197u8, 174u8, 197u8, 41u8, 124u8, 19u8, 3u8]
        }

        pub fn data(data: InitializeExtraAccountMetaListInstructionData) -> Self {
            Self {
                accounts: InitializeExtraAccountMetaListInstructionAccountMetas::default(),
                data,
                remaining_accounts: Vec::new(),
            }
        }

        pub fn accounts(
            mut self,
            accounts: InitializeExtraAccountMetaListInstructionAccounts,
        ) -> Self {
            self.accounts.authority = AccountMeta::new(accounts.authority, true);

            self.accounts.extra_account_meta_list =
                AccountMeta::new(accounts.extra_account_meta_list, false);

            self.accounts.mint = AccountMeta::new_readonly(accounts.mint, false);

            self.accounts.system_program =
                AccountMeta::new_readonly(pubkey!("11111111111111111111111111111111"), false);

            self
        }

        pub fn remaining_accounts(mut self, accounts: Vec<AccountMeta>) -> Self {
            self.remaining_accounts = accounts;
            self
        }

        fn to_account_metas(&self) -> Vec<AccountMeta> {
            let mut metas = Vec::new();

            metas.push(self.accounts.authority.clone());

            metas.push(self.accounts.extra_account_meta_list.clone());

            metas.push(self.accounts.mint.clone());

            metas.push(self.accounts.system_program.clone());

            metas.extend(self.remaining_accounts.clone());
            metas
        }

        pub fn instruction(&self) -> Instruction {
            let mut buffer: Vec<u8> = Vec::new();

            buffer.extend_from_slice(&Self::discriminator());

            self.data.serialize(&mut buffer).unwrap();

            Instruction::new_with_bytes(program_id(), &buffer, self.to_account_metas())
        }
    }

    // ------------------------------------------------------------------------
    // Composite Accounts
    // ------------------------------------------------------------------------
}

// ============================================================================
// CUSTOM TYPES
// ============================================================================

/// Custom struct: AccountFrozen
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AccountFrozen {
    pub stablecoin: Pubkey,

    pub account: Pubkey,

    pub frozen_by: Pubkey,

    pub timestamp: i64,
}

impl AccountFrozen {
    pub fn new(stablecoin: Pubkey, account: Pubkey, frozen_by: Pubkey, timestamp: i64) -> Self {
        Self {
            stablecoin,

            account,

            frozen_by,

            timestamp,
        }
    }
}

/// Custom struct: AccountThawed
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AccountThawed {
    pub stablecoin: Pubkey,

    pub account: Pubkey,

    pub thawed_by: Pubkey,

    pub timestamp: i64,
}

impl AccountThawed {
    pub fn new(stablecoin: Pubkey, account: Pubkey, thawed_by: Pubkey, timestamp: i64) -> Self {
        Self {
            stablecoin,

            account,

            thawed_by,

            timestamp,
        }
    }
}

/// Custom struct: AddedToBlacklist
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AddedToBlacklist {
    pub stablecoin: Pubkey,

    pub address: Pubkey,

    pub reason: String,

    pub blacklisted_by: Pubkey,

    pub timestamp: i64,
}

impl AddedToBlacklist {
    pub fn new(
        stablecoin: Pubkey,

        address: Pubkey,

        reason: String,

        blacklisted_by: Pubkey,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            address,

            reason,

            blacklisted_by,

            timestamp,
        }
    }
}

/// Custom struct: AuthorityTransferred
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct AuthorityTransferred {
    pub stablecoin: Pubkey,

    pub previous_authority: Pubkey,

    pub new_authority: Pubkey,

    pub timestamp: i64,
}

impl AuthorityTransferred {
    pub fn new(
        stablecoin: Pubkey,

        previous_authority: Pubkey,

        new_authority: Pubkey,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            previous_authority,

            new_authority,

            timestamp,
        }
    }
}

/// Custom struct: BlacklistEntry
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct BlacklistEntry {
    pub stablecoin: Pubkey,

    pub address: Pubkey,

    pub reason: String,

    pub blacklisted_at: i64,

    pub blacklisted_by: Pubkey,

    pub bump: u8,
}

impl BlacklistEntry {
    pub fn new(
        stablecoin: Pubkey,

        address: Pubkey,

        reason: String,

        blacklisted_at: i64,

        blacklisted_by: Pubkey,

        bump: u8,
    ) -> Self {
        Self {
            stablecoin,

            address,

            reason,

            blacklisted_at,

            blacklisted_by,

            bump,
        }
    }
}

/// Custom struct: InitializeParams
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct InitializeParams {
    pub name: String,

    pub symbol: String,

    pub uri: String,

    pub decimals: u8,

    pub enable_permanent_delegate: bool,

    pub enable_transfer_hook: bool,

    pub default_account_frozen: bool,
}

impl InitializeParams {
    pub fn new(
        name: String,

        symbol: String,

        uri: String,

        decimals: u8,

        enable_permanent_delegate: bool,

        enable_transfer_hook: bool,

        default_account_frozen: bool,
    ) -> Self {
        Self {
            name,

            symbol,

            uri,

            decimals,

            enable_permanent_delegate,

            enable_transfer_hook,

            default_account_frozen,
        }
    }
}

/// Custom struct: MinterInfo
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct MinterInfo {
    pub stablecoin: Pubkey,

    pub minter: Pubkey,

    pub quota: u64,

    pub minted_amount: u64,

    pub bump: u8,
}

impl MinterInfo {
    pub fn new(
        stablecoin: Pubkey,

        minter: Pubkey,

        quota: u64,

        minted_amount: u64,

        bump: u8,
    ) -> Self {
        Self {
            stablecoin,

            minter,

            quota,

            minted_amount,

            bump,
        }
    }
}

/// Custom struct: MinterUpdated
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct MinterUpdated {
    pub stablecoin: Pubkey,

    pub minter: Pubkey,

    pub new_quota: u64,

    pub updated_by: Pubkey,

    pub timestamp: i64,
}

impl MinterUpdated {
    pub fn new(
        stablecoin: Pubkey,

        minter: Pubkey,

        new_quota: u64,

        updated_by: Pubkey,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            minter,

            new_quota,

            updated_by,

            timestamp,
        }
    }
}

/// Custom struct: RemovedFromBlacklist
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RemovedFromBlacklist {
    pub stablecoin: Pubkey,

    pub address: Pubkey,

    pub removed_by: Pubkey,

    pub timestamp: i64,
}

impl RemovedFromBlacklist {
    pub fn new(stablecoin: Pubkey, address: Pubkey, removed_by: Pubkey, timestamp: i64) -> Self {
        Self {
            stablecoin,

            address,

            removed_by,

            timestamp,
        }
    }
}

/// Custom struct: RoleAccount
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RoleAccount {
    pub stablecoin: Pubkey,

    pub holder: Pubkey,

    pub roles: RoleFlags,

    pub bump: u8,
}

impl RoleAccount {
    pub fn new(stablecoin: Pubkey, holder: Pubkey, roles: RoleFlags, bump: u8) -> Self {
        Self {
            stablecoin,

            holder,

            roles,

            bump,
        }
    }
}

/// Custom struct: RoleFlags
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RoleFlags {
    pub is_minter: bool,

    pub is_burner: bool,

    pub is_pauser: bool,

    pub is_freezer: bool,

    pub is_blacklister: bool,

    pub is_seizer: bool,
}

impl RoleFlags {
    pub fn new(
        is_minter: bool,
        is_burner: bool,
        is_pauser: bool,
        is_freezer: bool,
        is_blacklister: bool,
        is_seizer: bool,
    ) -> Self {
        Self {
            is_minter,
            is_burner,
            is_pauser,
            is_freezer,
            is_blacklister,
            is_seizer,
        }
    }
}

/// Custom struct: RolesUpdated
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct RolesUpdated {
    pub stablecoin: Pubkey,
    pub holder: Pubkey,
    pub is_minter: bool,
    pub is_burner: bool,
    pub is_pauser: bool,
    pub is_freezer: bool,
    pub is_blacklister: bool,
    pub is_seizer: bool,
    pub updated_by: Pubkey,
    pub timestamp: i64,
}

impl RolesUpdated {
    pub fn new(
        stablecoin: Pubkey,
        holder: Pubkey,
        is_minter: bool,
        is_burner: bool,
        is_pauser: bool,
        is_freezer: bool,
        is_blacklister: bool,
        is_seizer: bool,
        updated_by: Pubkey,
        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,
            holder,
            is_minter,
            is_burner,
            is_pauser,
            is_freezer,
            is_blacklister,
            is_seizer,
            updated_by,
            timestamp,
        }
    }
}

/// Custom struct: StablecoinInitialized
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct StablecoinInitialized {
    pub stablecoin: Pubkey,

    pub mint: Pubkey,

    pub authority: Pubkey,

    pub name: String,

    pub symbol: String,

    pub is_sss2: bool,

    pub timestamp: i64,
}

impl StablecoinInitialized {
    pub fn new(
        stablecoin: Pubkey,

        mint: Pubkey,

        authority: Pubkey,

        name: String,

        symbol: String,

        is_sss2: bool,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            mint,

            authority,

            name,

            symbol,

            is_sss2,

            timestamp,
        }
    }
}

/// Custom struct: StablecoinPaused
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct StablecoinPaused {
    pub stablecoin: Pubkey,

    pub paused_by: Pubkey,

    pub timestamp: i64,
}

impl StablecoinPaused {
    pub fn new(stablecoin: Pubkey, paused_by: Pubkey, timestamp: i64) -> Self {
        Self {
            stablecoin,

            paused_by,

            timestamp,
        }
    }
}

/// Custom struct: StablecoinState
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct StablecoinState {
    pub authority: Pubkey,

    pub mint: Pubkey,

    pub name: String,

    pub symbol: String,

    pub uri: String,

    pub decimals: u8,

    pub enable_permanent_delegate: bool,

    pub enable_transfer_hook: bool,

    pub default_account_frozen: bool,

    pub paused: bool,

    pub total_minted: u64,

    pub total_burned: u64,

    pub bump: u8,
}

impl StablecoinState {
    pub fn new(
        authority: Pubkey,

        mint: Pubkey,

        name: String,

        symbol: String,

        uri: String,

        decimals: u8,

        enable_permanent_delegate: bool,

        enable_transfer_hook: bool,

        default_account_frozen: bool,

        paused: bool,

        total_minted: u64,

        total_burned: u64,

        bump: u8,
    ) -> Self {
        Self {
            authority,

            mint,

            name,

            symbol,

            uri,

            decimals,

            enable_permanent_delegate,

            enable_transfer_hook,

            default_account_frozen,

            paused,

            total_minted,

            total_burned,

            bump,
        }
    }
}

/// Custom struct: StablecoinUnpaused
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct StablecoinUnpaused {
    pub stablecoin: Pubkey,

    pub unpaused_by: Pubkey,

    pub timestamp: i64,
}

impl StablecoinUnpaused {
    pub fn new(stablecoin: Pubkey, unpaused_by: Pubkey, timestamp: i64) -> Self {
        Self {
            stablecoin,

            unpaused_by,

            timestamp,
        }
    }
}

/// Custom struct: TokensBurned
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TokensBurned {
    pub stablecoin: Pubkey,

    pub burner: Pubkey,

    pub amount: u64,

    pub total_burned: u64,

    pub timestamp: i64,
}

impl TokensBurned {
    pub fn new(
        stablecoin: Pubkey,

        burner: Pubkey,

        amount: u64,

        total_burned: u64,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            burner,

            amount,

            total_burned,

            timestamp,
        }
    }
}

/// Custom struct: TokensMinted
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TokensMinted {
    pub stablecoin: Pubkey,

    pub minter: Pubkey,

    pub recipient: Pubkey,

    pub amount: u64,

    pub total_minted: u64,

    pub timestamp: i64,
}

impl TokensMinted {
    pub fn new(
        stablecoin: Pubkey,

        minter: Pubkey,

        recipient: Pubkey,

        amount: u64,

        total_minted: u64,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            minter,

            recipient,

            amount,

            total_minted,

            timestamp,
        }
    }
}

/// Custom struct: TokensSeized
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone)]
pub struct TokensSeized {
    pub stablecoin: Pubkey,

    pub from: Pubkey,

    pub to: Pubkey,

    pub amount: u64,

    pub seized_by: Pubkey,

    pub timestamp: i64,
}

impl TokensSeized {
    pub fn new(
        stablecoin: Pubkey,

        from: Pubkey,

        to: Pubkey,

        amount: u64,

        seized_by: Pubkey,

        timestamp: i64,
    ) -> Self {
        Self {
            stablecoin,

            from,

            to,

            amount,

            seized_by,

            timestamp,
        }
    }
}

// ============================================================================
// END OF GENERATED FILE
// ============================================================================
